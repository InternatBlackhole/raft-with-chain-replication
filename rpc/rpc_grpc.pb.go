// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ReplicationProviderClient is the client API for ReplicationProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicationProviderClient interface {
	PutInternal(ctx context.Context, in *InternalEntry, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Commit(ctx context.Context, in *EntryCommited, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type replicationProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationProviderClient(cc grpc.ClientConnInterface) ReplicationProviderClient {
	return &replicationProviderClient{cc}
}

func (c *replicationProviderClient) PutInternal(ctx context.Context, in *InternalEntry, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ReplicationProvider/PutInternal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationProviderClient) Commit(ctx context.Context, in *EntryCommited, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ReplicationProvider/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicationProviderServer is the server API for ReplicationProvider service.
// All implementations must embed UnimplementedReplicationProviderServer
// for forward compatibility
type ReplicationProviderServer interface {
	PutInternal(context.Context, *InternalEntry) (*emptypb.Empty, error)
	Commit(context.Context, *EntryCommited) (*emptypb.Empty, error)
	mustEmbedUnimplementedReplicationProviderServer()
}

// UnimplementedReplicationProviderServer must be embedded to have forward compatible implementations.
type UnimplementedReplicationProviderServer struct {
}

func (UnimplementedReplicationProviderServer) PutInternal(context.Context, *InternalEntry) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutInternal not implemented")
}
func (UnimplementedReplicationProviderServer) Commit(context.Context, *EntryCommited) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedReplicationProviderServer) mustEmbedUnimplementedReplicationProviderServer() {}

// UnsafeReplicationProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationProviderServer will
// result in compilation errors.
type UnsafeReplicationProviderServer interface {
	mustEmbedUnimplementedReplicationProviderServer()
}

func RegisterReplicationProviderServer(s *grpc.Server, srv ReplicationProviderServer) {
	s.RegisterService(&_ReplicationProvider_serviceDesc, srv)
}

func _ReplicationProvider_PutInternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationProviderServer).PutInternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReplicationProvider/PutInternal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationProviderServer).PutInternal(ctx, req.(*InternalEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationProvider_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntryCommited)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationProviderServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReplicationProvider/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationProviderServer).Commit(ctx, req.(*EntryCommited))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReplicationProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ReplicationProvider",
	HandlerType: (*ReplicationProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutInternal",
			Handler:    _ReplicationProvider_PutInternal_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _ReplicationProvider_Commit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

// ReplicationControlClient is the client API for ReplicationControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicationControlClient interface {
	// The parameter is the node that is the new next node of the current node
	NextChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// The parameter is the node that is the new prev node of the current node
	PrevChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// The parameter is the node that is the new leader
	LeaderChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type replicationControlClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationControlClient(cc grpc.ClientConnInterface) ReplicationControlClient {
	return &replicationControlClient{cc}
}

func (c *replicationControlClient) NextChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ReplicationControl/NextChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationControlClient) PrevChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ReplicationControl/PrevChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationControlClient) LeaderChanged(ctx context.Context, in *Node, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ReplicationControl/LeaderChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicationControlServer is the server API for ReplicationControl service.
// All implementations must embed UnimplementedReplicationControlServer
// for forward compatibility
type ReplicationControlServer interface {
	// The parameter is the node that is the new next node of the current node
	NextChanged(context.Context, *Node) (*emptypb.Empty, error)
	// The parameter is the node that is the new prev node of the current node
	PrevChanged(context.Context, *Node) (*emptypb.Empty, error)
	// The parameter is the node that is the new leader
	LeaderChanged(context.Context, *Node) (*emptypb.Empty, error)
	mustEmbedUnimplementedReplicationControlServer()
}

// UnimplementedReplicationControlServer must be embedded to have forward compatible implementations.
type UnimplementedReplicationControlServer struct {
}

func (UnimplementedReplicationControlServer) NextChanged(context.Context, *Node) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextChanged not implemented")
}
func (UnimplementedReplicationControlServer) PrevChanged(context.Context, *Node) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrevChanged not implemented")
}
func (UnimplementedReplicationControlServer) LeaderChanged(context.Context, *Node) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaderChanged not implemented")
}
func (UnimplementedReplicationControlServer) mustEmbedUnimplementedReplicationControlServer() {}

// UnsafeReplicationControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationControlServer will
// result in compilation errors.
type UnsafeReplicationControlServer interface {
	mustEmbedUnimplementedReplicationControlServer()
}

func RegisterReplicationControlServer(s *grpc.Server, srv ReplicationControlServer) {
	s.RegisterService(&_ReplicationControl_serviceDesc, srv)
}

func _ReplicationControl_NextChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationControlServer).NextChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReplicationControl/NextChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationControlServer).NextChanged(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationControl_PrevChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationControlServer).PrevChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReplicationControl/PrevChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationControlServer).PrevChanged(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationControl_LeaderChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationControlServer).LeaderChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReplicationControl/LeaderChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationControlServer).LeaderChanged(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReplicationControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ReplicationControl",
	HandlerType: (*ReplicationControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NextChanged",
			Handler:    _ReplicationControl_NextChanged_Handler,
		},
		{
			MethodName: "PrevChanged",
			Handler:    _ReplicationControl_PrevChanged_Handler,
		},
		{
			MethodName: "LeaderChanged",
			Handler:    _ReplicationControl_LeaderChanged_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

// ControllerClient is the client API for Controller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllerClient interface {
	// GerLeader returns the leader address and port
	GetLeader(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error)
	// GetHead returns the head address and port
	GetHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error)
	// GetTail returns the tail address and port
	GetTail(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error)
}

type controllerClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerClient(cc grpc.ClientConnInterface) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) GetLeader(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := c.cc.Invoke(ctx, "/rpc.Controller/GetLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) GetHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := c.cc.Invoke(ctx, "/rpc.Controller/GetHead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) GetTail(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := c.cc.Invoke(ctx, "/rpc.Controller/GetTail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServer is the server API for Controller service.
// All implementations must embed UnimplementedControllerServer
// for forward compatibility
type ControllerServer interface {
	// GerLeader returns the leader address and port
	GetLeader(context.Context, *emptypb.Empty) (*Node, error)
	// GetHead returns the head address and port
	GetHead(context.Context, *emptypb.Empty) (*Node, error)
	// GetTail returns the tail address and port
	GetTail(context.Context, *emptypb.Empty) (*Node, error)
	mustEmbedUnimplementedControllerServer()
}

// UnimplementedControllerServer must be embedded to have forward compatible implementations.
type UnimplementedControllerServer struct {
}

func (UnimplementedControllerServer) GetLeader(context.Context, *emptypb.Empty) (*Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeader not implemented")
}
func (UnimplementedControllerServer) GetHead(context.Context, *emptypb.Empty) (*Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHead not implemented")
}
func (UnimplementedControllerServer) GetTail(context.Context, *emptypb.Empty) (*Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTail not implemented")
}
func (UnimplementedControllerServer) mustEmbedUnimplementedControllerServer() {}

// UnsafeControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllerServer will
// result in compilation errors.
type UnsafeControllerServer interface {
	mustEmbedUnimplementedControllerServer()
}

func RegisterControllerServer(s *grpc.Server, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_GetLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).GetLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Controller/GetLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).GetLeader(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_GetHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).GetHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Controller/GetHead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).GetHead(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_GetTail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).GetTail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Controller/GetTail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).GetTail(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLeader",
			Handler:    _Controller_GetLeader_Handler,
		},
		{
			MethodName: "GetHead",
			Handler:    _Controller_GetHead_Handler,
		},
		{
			MethodName: "GetTail",
			Handler:    _Controller_GetTail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

// PutProviderClient is the client API for PutProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PutProviderClient interface {
	Put(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type putProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewPutProviderClient(cc grpc.ClientConnInterface) PutProviderClient {
	return &putProviderClient{cc}
}

func (c *putProviderClient) Put(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.PutProvider/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PutProviderServer is the server API for PutProvider service.
// All implementations must embed UnimplementedPutProviderServer
// for forward compatibility
type PutProviderServer interface {
	Put(context.Context, *Entry) (*emptypb.Empty, error)
	mustEmbedUnimplementedPutProviderServer()
}

// UnimplementedPutProviderServer must be embedded to have forward compatible implementations.
type UnimplementedPutProviderServer struct {
}

func (UnimplementedPutProviderServer) Put(context.Context, *Entry) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedPutProviderServer) mustEmbedUnimplementedPutProviderServer() {}

// UnsafePutProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PutProviderServer will
// result in compilation errors.
type UnsafePutProviderServer interface {
	mustEmbedUnimplementedPutProviderServer()
}

func RegisterPutProviderServer(s *grpc.Server, srv PutProviderServer) {
	s.RegisterService(&_PutProvider_serviceDesc, srv)
}

func _PutProvider_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutProviderServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.PutProvider/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutProviderServer).Put(ctx, req.(*Entry))
	}
	return interceptor(ctx, in, info, handler)
}

var _PutProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.PutProvider",
	HandlerType: (*PutProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _PutProvider_Put_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

// ReadProviderClient is the client API for ReadProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReadProviderClient interface {
	Get(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*Entry, error)
}

type readProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewReadProviderClient(cc grpc.ClientConnInterface) ReadProviderClient {
	return &readProviderClient{cc}
}

func (c *readProviderClient) Get(ctx context.Context, in *Entry, opts ...grpc.CallOption) (*Entry, error) {
	out := new(Entry)
	err := c.cc.Invoke(ctx, "/rpc.ReadProvider/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReadProviderServer is the server API for ReadProvider service.
// All implementations must embed UnimplementedReadProviderServer
// for forward compatibility
type ReadProviderServer interface {
	Get(context.Context, *Entry) (*Entry, error)
	mustEmbedUnimplementedReadProviderServer()
}

// UnimplementedReadProviderServer must be embedded to have forward compatible implementations.
type UnimplementedReadProviderServer struct {
}

func (UnimplementedReadProviderServer) Get(context.Context, *Entry) (*Entry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedReadProviderServer) mustEmbedUnimplementedReadProviderServer() {}

// UnsafeReadProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReadProviderServer will
// result in compilation errors.
type UnsafeReadProviderServer interface {
	mustEmbedUnimplementedReadProviderServer()
}

func RegisterReadProviderServer(s *grpc.Server, srv ReadProviderServer) {
	s.RegisterService(&_ReadProvider_serviceDesc, srv)
}

func _ReadProvider_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadProviderServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ReadProvider/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadProviderServer).Get(ctx, req.(*Entry))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReadProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ReadProvider",
	HandlerType: (*ReadProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ReadProvider_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}
